Within computer science, time efficiency and scalability of programs for larger and larger data sets have become ever so important with the advancement of technology. Also within computer science, new areas of discussion for time efficiency have come up in recent years, including artificial intelligence and machine learning. These two technologies are based on processing huge data sets and repeatedly carrying out operations. All of these programs are based upon instructions written by humans referred to as code. When using math functions such as sine, cosine and logarithms the conventional way to do so in code is to use the long and complicated, as to achieve high accuracy answers, external libraries which have been coded by other computer scientists long ago. These math functions are often used in physics simulations but used in other ways are also important to computer programs and I propose simplifying these functions can save time for the same result.

My aim therefore is to see how the simplification the mathematical functions using both the Taylor and McLaurin series to lower run times of computational programs in which the functions are used. I‚Äôll compare the run times of programs using the function.
My rationale for exploring this topic is because I believe from test runs, I‚Äôve conducted that this may yield interesting results for improving the efficiency of computational programs. Using these simplification methods can result in time spent working the polynomial out and implementing it in code but can save hundreds of hours over the long run.

Conclusion:
Returning to my aim at the beginning of the investigation, to simplify the mathematical functions using both the Taylor and McLaurin series to lower run times of computational programs in which the functions are used. I believe I was able to achieve this aim and gain interesting insight in the way different functions are built and how this effects the time saved when simplified. The three functions provided insight in how more complicated functions will benefit from the simplification using McLaurin and Taylor series.

The way I evaluated each polynomial‚Äôs significance and usefulness was in reference to the average instructions per second done by a modern computer and if it would be noticeable to the human eye and perception of the program. Although I stand by this method of evaluation, many more perspectives can be taken where these simplifications may be much more significant or much less. I provided the perspective I believed made most sense and I had the most knowledge in.
I learnt an impactful lesson on math in coding and how I should always be looking to optimize especially math when coding. Even though not done in this investigation an extension I‚Äôd be interested in looking into is negating the main disadvantage of McLaurin and Taylor polynomials in practical use, the small range they are accurate. There may be a way to implement something in code which can both save time and have an adaptive Taylor polynomial which can be accurate for all ùë• values which I would find to be very interesting. Additionally, when looking into the time investment needed for finding and implementing the polynomials I think for my future endeavors in code I will only use this method of simplification when absolutely needed to optimize my programs, especially since it usually results in messy and cluttered code. In conclusion, the use of the McLaurin and Taylor series to simplify mathematical functions is a viable method to lower run times of computations programs in which the functions are being repeated but limits the range of ùë• values for which the functions can be used.
